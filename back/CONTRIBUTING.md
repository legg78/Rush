# Правила создания объектов базы данных

Базовая кодировка файлов объектов баз данных - UTF-8(UTF-8 without BOM) 

## Правила именования объектов БД

* Объекты базы данных именуются на грамотном английском языке.
* Названия объектов БД должно быть интуитивно понятно и пояснять его смысл.
* Названия объектов не должно содержать имен собственных (названий клиентов, имен разработчиков, компании БПЦ, торговых марок SmartVista, SV и т.п.)
* Отдельные слова, из которых состоит имя объекта, разделяются символом «_» (подчеркивание).
* Необходимо избегать сокращений в именах объектов.
* Категорически запрещается использовать транслит (напр. TABLICA_ZAKUPOK) в именовании объектов БД.
* В сложных (составных) именах объектов сначала указывается сущность, затем дополнение (напр. ISS_CARD_TEMPLATE_VW, ISS_CARD_STATUS_HISTORY_VW).
* Названия объектов напрямую относящихся к таблице (индекс, триггер, сиквенс, констрейнт) должны иметь такое же имя, как и таблица, но со своим суффиксом.
* Желательно, таким же образом называть пакеты, если их работа в основном связана с данными определенной таблицы, либо имеет одно с ней назначение.
* В каждом модуле создаются два или больше пакета группирующие в себе интерфейсные процедуры и функции. Для пакета, содержащего в себе функции для пользовательского интерфейса, используется дополнительный префикс UI (user interface). Для пакета, содержащего в себе функции, которые используются другими модулями, используется дополнительный префикс API (application interface). Другие модули могут использовать только процедуры и функции определенные в пакетах с префиксом API. (ACC_UI_BALANCE_PKG, ACC_API_BALANCE_PKG)
* В именах объектов допускаются сокращения (кроме имен таблиц) если длина имени превышает максимально возможную длину, или слово, содержащееся в имени, имеет длину более 8 символов. Сокращение слова производится до 4-5 символов.

	Имя объекта выполняется в следующем формате:
	<pre>
[префикс]_[объект]_[характеристика|дополнение]_[суффикс]
	</pre>

	Префикс - трехбуквенный код модуля, к которому относиться объект

	Суффикс - трехбуквенный код типа объекта.

	Варианты суффиксов:

* Таблицы именуются без суффиксов
* SEQ - последовательность
* UK - уникальный ключ
* NDX - индекс
* TRG - триггер
* PKG - пакет
* VW - представление
* MVW - материализованное представление
* FK - внешний ключ
* PK - первичный ключ
* TBS - табличное пространство
* TPR - объектный тип - запись
* TPT - объектный тип - коллекция


## Ограничения на создания объектов

### Первичные ключи (primary key)
В каждой таблице обязательно наличие первичного ключа - поля "ID" и крайне желательно наличие уникального индекса по совокупности полей, значения которых уникально идентифицируют конкретную запись таблицы. Значение первичного ключа генерируется с помощью последовательности (sequence). Имя последовательности состоит из названия таблицы и суффикса "_SEQ".

### Внешние ключи (foreign key)
Внешние ключи (foreign key) именуются следующим образом: сначала указывается название таблицы, на которой строится внешний ключ, затем, после знака подчеркивания указывается название таблицы, к которой строится внешний ключ. В конце указывается «_FK». Например: EMPLOYEE_DEPT_FK. Запрещается создавать каскадные внешние ключи. Внешние ключи имеют только внутреннее назначение и клиентам не устанавливаются (не сохраняются в репозитарий).

### Индексы (indexes)
Название индекса формируется следующим образом: сначала указывается название таблицы, затем название поля таблицы (или нескольких полей, по которым строится индекс). В конце названия индекса в случае normal-индекса, указывается суффикс «_NDX» (EMPLOYEE_HIREDATE_NDX), в случае уникального индекса суффикс «_UK» (SALARY_EMPLOYEE_UK). В случае если название индекса превышает максимальное кол-во символов, разрешается использовать сокращения.

### Проверочные констрейнты (check constraints)
CHECK CONSTRAINTS запрещены, все проверки правильности значений, попадаемых в таблицу производятся в пакетах. Кроме того, крайне не рекомендуется создавать констрейнты NOT NULL. Если, в исключительной ситуации, требуется создать констрейнт NOT NULL, то он создается явно (вне конструкции CREATE TABLE или ALTER TABLE MODIFY COLUMN) и явно именуется с суффиксом _NNL.

### Триггеры (triggers)
Использование триггеров запрещено. В случае непреодолимого желания использовать триггеры решение об этом принимается отдельно архитектором и каждый случай использования описывается. Исключение действует на автоматически генерируемые триггеры, создаваемые в целях ведения аудита.

### Процедуры и функции (procedures and functions)
Все процедуры и функции должны быть оформлены в пакетах. Запрещается написание процедур и функций вне пакетов. Вся логика, изменение данных в БД реализуется с помощью пакетных процедур и функций. Все логически обособленные процедуры должны быть оформлены в виде одного пакета, название которого поясняет его предметную область.
Разрешается использовать функции для получения констант и переменных окружения в представлениях.

### Поля (columns)
Поля именуются в соответствии с требованиями к остальным объектам. Имя поля должно быть максимально коротким, полно описывающим назначение поля, без сокращений (по возможности). Можно использовать сокращения слов в именах колонок, только если слово содержит от 8 и более букв. Если в таблице используется поле из другой таблицы (ссылка) то поле должно именоваться следующим образом «имя объекта»_«имя поля». Имя поля не должно содержать имя собственной таблицы, разрешается добавлять имя таблицы к имени колонки, только в случае если без него имя поля становиться зарезервированным словом. Имя таблицы всегда используется без префикса. BOOLEAN-поля реализуются с помощью NUMBER-поля, которое может принимать только два значения: 0 - FALSE, 1 - TRUE.

### Комментарии к объектам (comments)
Каждый объект должен иметь комментарий и комментарии на каждое поле, если это таблица или представление. Все комментарии пишутся на английском языке.

### Представления (views)
Все представления должны создаваться с использованием конструкции FORCE. В представлении должны явно перечисляться все используемые поля, запрещено использование «*» при определении списка полей.

### Материализованные представления (materialized views)
Материализованные представления могут строиться только на основе запросов напрямую из таблиц. Они не могут обращаться к представлениям (view). Данное ограничение введено с целью предотвращения зацикливания зависимости объектов друг от друга, что может привести к невозможности автоматической сборки системы.

## Атрибуты хранения объектов БД
Все атрибуты хранения объектов БД, такие как:

* Табличное пространство
* Партиционирование
* Экстенты
* Параллельность
* Логирование
* Кэширование (разрешено выставлять размер кэша последовательности через alter)

'''НЕ''' определяются в скриптах на создание объектов.
Все эти атрибуты определяются в момент имплементации системы, под каждого конкретного клиента.

# Оформление кода
## Именование идентификаторов

### Общие понятия

* <strong>Помните!</strong> Код чаще читается, чем пишется, поэтому не экономьте на понятности и чистоте кода ради скорости набора.
* Не используйте малопонятные префиксы или суффиксы.
* Старайтесь не использовать сокращения лишний раз, помните о тех, кто читает код.
* Старайтесь делать имена идентификаторов как можно короче (но не в ущерб читабельности). Главное, чтобы смысл идентификатора был понятен в используемом контексте. Например, количество элементов коллекции лучше назвать count, а не count_of_elements_in_my_collection.
* Когда придумываете название для нового, общедоступного (public) класса, пространства имен или интерфейса, старайтесь не использовать имена, потенциально или явно конфликтующие со стандартными идентификаторами.
* Предпочтительно использовать имена, которые ясно и четко описывают предназначение и/или смысл сущности.
* Старайтесь использовать имена с простым написанием. Их легче читать и набирать. Избегайте (в разумных пределах) использования слов с двойными буквами, сложным чередованием согласных. Прежде, чем остановиться в выборе имени, убедитесь, что оно легко пишется и однозначно воспринимается на слух. Если оно с трудом читается, и вы ошибаетесь при его наборе, возможно, стоит выбрать другое.


### Стили использования регистра букв
За основу оформления кода берется стандарт оформления кода на «С++». Весь код, кроме констант, оформляется в нижнем регистре.<br>
Переменные именуются в нижнем регистре с разделением слов подчеркиванием либо без разделения. Переменная должна иметь префикс обозначающий область ее использования:

* g - глобальная переменная;
* l - локальная переменная;
* i - входной параметр in;
* io - входной параметр in out.
* o - входной параметр out

Константы, объявляемые в пакете, должны именоваться в верхнем регистре без префикса.
Пример:

```
g_table_name varchar2(30);
l_tablename varchar2(30);
DEFAULT_TABLE_NAME constant varchar2(30) 'NEWTABLE';
```

### Типы, используемые для определения параметров и переменных
Для определения переменных и констант запрещается использовать исходные типы БД. Необходимо использовать только домены типов определенные в пакете типов.

```
g_table_name com_api_type_pkg.t_oracle_name;
l_tablename com_api_type_pkg.t_oracle_name;
DEFAULT_TABLE_NAME constant com_api_type_pkg.t_oracle_name 'NEWTABLE';
```

Если необходимо добавить новый домен, нужно обратиться к архитектору БД, чтобы он рассмотрел этот вопрос и при необходимости добавил новый домен.

## Расстановка скобок и табуляция
Для расстановки скобок используется стиль 1TBS. Расшифровывается как One True Bracing Style (единственный правильный стиль расстановки скобок). Иногда его называют K&amp;R (Kernighan and Ritchie) или kernel стилем. Ставьте скобки только там где без них действительно не обойтись. Перегруженность кода скобками снижает его читабельность. Вместо знаков табуляции необходимо использовать пробелы. Один знак табуляции равен 4-м пробелам.

```
procedure p1(
    i_parameter in pls_integer
) is
begin
    if i_parameter != 0 then
        for i in (
            select text_field
              from some_table
             where id_field = i_parameter
        ) loop
            dbms_output.put_line(i.text_field);
        end loop;
    end if;
end;
```

## Пробелы в строке

* После запятой должен быть пробел. После точки с запятой, если она не последняя в строке, должен быть пробел. Перед запятой или точкой с запятой пробелы не ставятся.
* После открывающей скобки и перед закрывающей скобкой пробелы не ставятся.
* Все операторы должны быть отделены пробелом от операндов с обеих сторон.
* Логически связный блок регулярной структуры желательно форматировать в виде таблицы. При этом для выравнивания в таблице следует использовать пробелы, но не табуляцию.

```
if(a=b)then -- неверно

if (a = b) then -- верно

-- табличное форматирование
l_name       varchar2(10) := "Mr. Ed";
l_my_value   pls_integer  := 5;
l_test       varchar2(15) := i_test;
```

## Комментарии в коде

* Комментарии в коде выполняются на английском языке, без использования нецензурных выражений, шуток, приколов, цитат из баша и прочего.
* Не допускаются в комментариях имена разработчиков, номера заявок, даты когда и кем изменение, следующее за комментарием было сделано. А также, не допускается в принципе добавление комментариев описывающих сделанные изменения. Комментарии должны содержать только описание функциональности на текущий момент. Комментарии к изменениям пишутся при сохранении изменений в репозитарий.
* Не используйте многострочные (/*...*/) комментарии для описания логики работы кода. Многострочные комментарии не могут быть вложенными, поэтому их использование может создать проблемы. Исключение составляют комментарий, которые используются для автогенерации документации. Для них используются правила, описанные в руководстве пользователя по документатору.
* Для описания сути некоторого участка кода, пояснений к алгоритму и другой важной информации используйте несколько подряд идущих однострочных комментариев (--...). Между группой комментариев и собственно кодом поставьте пустую строку. Это покажет, что комментарий относится к блоку кода, а не к конкретной инструкции. Напротив, если комментарий относится к конкретной инструкции, прижмите его вплотную к этой инструкции.
* Отделяйте текст комментария одним пробелом «-- Текст комментария.».
* Комментируя код, старайтесь объяснять, что он делает, а не какая операция производится. Так, инструкции if соответствует выражение «если... то...», причем часть, идущая за «то», является кодом, который будет выполняться, если выражение в if будет верным. Таким образом, для конструкции «if utl_file.is_open(l_file_name)», нужно написать комментарий «-- Если выбранный файл открыт, то...», а не «-- Производим проверку на открытие файла и, если он открыт, закрываем его». Часть предложения, идущую за «то», вписывайте непосредственно перед выполнением конкретных действий. Для инструкций, осуществляющих действия, пишите «-- Производим...» или «-- Делаем...», где вместо троеточия вписывайте описания действий. Описывая действия, старайтесь описывать суть происходящего, а не то, что делают те или иные операторы. Так, совершенно бессмысленны комментарии вроде «Присваиваем переменной a значение b» или «вызываем метод f».
* Помните, что экономить на комментариях нельзя. Однако не стоит также формально подходить к процессу создания комментариев. Задача комментария - упростить понимание кода. Есть немало случаев, когда сам код отличным образом себя документирует.

```
-- indentation level
l_level number;
l_size number; -- size of table

-- Line 1
-- Line 2
--
for i in 0..l_list.count loop
...
```

## Оформление запросов и вызовов процедур
Запросы пишутся в виде матрицы. Каждое поле в выборке, таблица или предикат в условии запроса пишутся в отдельной строке. Условия AND, OR, запятые разделяющие список таблиц и полей выносятся вперед. В запросе должны явно перечисляться все используемые поля, запрещено использование «*» при определении списка полей.
```sql
select next_date
  into o_new_finish_date
  from fcl_cycle_counter
 where cycle_type = i_cycle_type
   and object_id = i_object_id
   and entity_type = i_entity_type
   and split_hash = i_split_hash;
```
Все вызовы процедур и функций должны писаться с явным определением передаваемых параметров. При оформлении должны использоваться те же принципы расстановки скобок отступов и запятых, что были описаны выше.
```sql
l_cycle_id :=
    rul_api_product_pkg.get_cycle_id(
        i_product_id  =: i_prod_id
      , i_entity_type =: i_entity_type
      , i_object_id   =: i_object_id
      , i_cycle_type  =: i_cycle_type
      , i_params      =: i_params
      , i_eff_date =: l_eff_date
    );
```
## Документирование кода

Для автоматической генерации технической документации по коду используется утилита <a href="http://pldoc.sourceforge.net">pldoc</a>. Чтобы использовать эту утилиту необходимо в код вставлять комментарии, написанные с использованием определенных правил.

Каждый пакет после объявления должен содержать комментарий следующего формата:


    create or replace package xxx_some_package_pkg as
    /**************************************************
     *
     * Some description of package destination and functionality
     * . . .
     * . . .
     *  . . .
     * Created by Author at dd.mm.yyyy
     * Last changed by Developer at dd.mm.yyyy
     * Module:
     * @headcom
     ****************************************************/

Каждая процедура или функция, объявленная в пакете, должна предваряться комментарием следующего формата:


    /**************************************************
     *
     * Gets customer by ID.
     *
     * @param p_id customer ID&lt;
     * @return customer description
     * @throws no_data_found if no such customer exists
     *
     ***************************************************/
    function get_customer (
        p_id in    varchar2&lt;
    ) return varchar2;


В описании могут использоваться следующие теги:

* @headcom - определяет заголовок пакета
* @param - предваряет входной параметр процедуры, после него через пробел должны следовать имя параметра и описание
* @return - описание значения возвращаемого функцией
* @throws - перечисление исключений, порождаемых в коде процедуры. После тега через пробел должны следовать имя исключения и условие, при котором оно возникает.
* @deprecated - этим тэгом помечаются устаревшие процедуры, использование которых не рекомендуется. В описание после этого параметра следует указать новую процедуру, которую необходимо использовать вместо устаревшей.

В тексте комментариев можно указывать HTML теги.

Первое предложение в комментарии, заканчивающееся точкой, будет использовано в описании процедуры в перечислении процедур в заголовке.

Все теги, используемые в описании, необходимо использовать после основного текста комментария. <strong>Каждая строка описания должна начинаться с символа «*».</strong>

## Обработка исключительных ситуаций (ошибок)
При возникновении любой исключительной ситуации система должна генерировать собственное сообщение об ошибке с описанием понятным пользователю системы. Не должно возникать исключений со стандартными ошибками БД, операционной системы и т.п.
Для генерации исключения приложения используется стандартная единая процедура вызова исключения. В качестве параметров процедуре передается кодовое имя ошибки из словаря сообщений и до 6 параметров окружения. Каждое сообщение должно быть предварительно зарегистрировано в справочнике сообщений. Справочник сообщений используется для поддержки многоязыковых сообщений. Кроме сообщений об ошибках должны так же регистрироваться все остальные типы сообщений.
В системе существует два типа ошибок обычные и фатальные, фатальные ошибки приводят к полному останову системы до момента устранения ошибки. Обычные же ошибки не приводят к останову всей системы, а просто прекращают выполнение одного определенного действия и делают пометку об этом событии в логе. Какой тип ошибки использовать в том или ином случае остается на усмотрение разработчика.
Все непоименованные исключения базы данных, которые необходимо перехватывать должны быть проинициализированы как константы типа exception в пакете com_api_error_pkg. В каждом блоке обработки исключения должен присутствовать условие others, в котором должен быть вызов фатальной ошибки с сообщением UNHANDLED_EXCEPTION и кодом ошибки в качестве параметра. Условие others может содержать в себе только такую обработку.
Пример обработки ошибки:


    begin
        . . . .
    exception
        when no_data_found then
            com_api_error_pkg.raise_error(
                i_error =: 'ACCOUNT_NOT_FOUND'
              , i_env_param1 =: i_account_number
            );
        when com_api_error_pkg.e_resource_busy then
            com_api_error_pkg.raise_error(
                i_error =: 'ACCOUNT_IN_PROCESSING'
              , i_env_param1 =: i_account_number
            );
        when com_api_error_pkg.e_application_error then
            raise;
        when com_api_error_pkg.e_fatal_error then
            raise;
        when others then
            com_api_error_pkg.raise_fatal_error(
                i_error =: 'UNHANDLED_EXCEPTION'
              , i_env_param1 =: SQLERRM
            );
    end;


## Правила написания сообщений об ошибках
Для каждого исключения генерируемого в системе должно быть зарегистрировано мультиязычное сообщение. Первично текст сообщения регистрируется на английском языке. Дополнительно к каждому сообщению регистрируется список параметров окружения, при которых данное исключение произошло. Некоторые значения могут подставляться прямо в текст сообщения путем указания специальных тэгов [#1], где #1 заменяется впоследствии на конкретное значение. Однако, не следует перегружать сообщение значениями. Тем более не следует выводить в текст сообщения внутренние идентификаторы объектов и любою другу системную информацию, которая может ввести оператора в замешательство. Для сообщений, которые явно связаны с работой с каким-либо конкретным объектом, необходимо передавать идентификатор этого объекта.

Содержание текста ошибки должно быть максимально лаконичным и простым, '''дабы не шокировать оператора литературными изысками и синтаксическими ошибками.'''

Возможны следующие варианты сообщений об ошибках:

система не может выполнить запрошенную операцию т.к. не находит какой либо объект необходимый для выполнения операции: 
''Объект не найден.''

система не может выполнить операцию, поскольку некий объект уже существует (нарушение уникального ключа): 
''Объект уже существует.''

система не может выполнить операцию, т.к. подобная операция запрещена по бизнес требованиям: 
''Невозможно выполнить «название операции».''

система не может выполнить операцию, т.к. наличие (отсутствие) каких-либо данных не позволяет этого сделать: 
''Невозможно выполнить «название операции», т.к. «ситуация с данными, которая не позволяет выполнить операцию».''

оператор не имеет прав на выполнение определенной операции: 
''У Вас нет прав на выполнение «название операции». Обратитесь к администратору.''

Шаблоны описаний на английском языке:
<ul type="square">
<li>&lt;OBJECT&gt; not found. Пример: Account not found.
<li>&lt;OBJECT&gt; already exists. Пример: Customer already exists.
<li>Unable to &lt;ACTION&gt; &lt;WITH SOME DATA&gt;. Пример: Unable to change account type.
<li>Unable to &lt;ACTION&gt; &lt;WITH SOME DATA&gt;. &lt;REASON&gt;. Пример: Unable to remove product. Product already assigned to contract(s).
<li>Not enough rights to &lt;PERFORM OPERATION&gt;. Пример: Not enough rights to set value of parameter [Split degree].
</ul>

## Поддержание принципа модульности и аудирование.
Система разбита на модули. Модули имеют иерархию подчинения (использование одним модулем другого). Модуль, предоставляющий интерфейс для другого модуля, в свою очередь не может использовать интерфейс «подчиненного» модуля, за исключением модулей входящих в ядро системы. Все интерфейсные процедуры и функции, которые модуль предоставляет для использования другим программным продуктам, подсистемам и модулям группируются в отдельные пакеты, этих пакетов может быть несколько, но они все должны именоваться соответствующим образом (см. именование объектов).
Пакеты, предоставляющие функции для работы пользовательского интерфейса, именуются с дополнительным префиксом UI. Все подобные пакеты могут обращаться только к представлениям, обращение из этих пакетов напрямую к таблицам запрещено. Это связано с механизмом аудирования действий пользователя в системе. На каждое представление, используемое в пользовательском интерфейсе, автоматически генерируется триггер INSTEAD OF, который сам производит действия над таблицами и сохраняет аудируюмую информацию. Для того чтобы триггер сформировался необходимо зарегистрировать аудируемый объект в таблице ADT_ENTITY.
Пакеты, вызываемые другими модулями, помечаются дополнительным префиксом API и группируют в себе интерфейсные функции, предоставляемые для использования внутри системы. Эти процедуры в отличие от пользовательских обращаются на прямую к таблицам и не используют представления. Таким образом, с системе аудируются действия пользователей и не аудируются действия, выполняемые автоматическими процессами.
Пакеты, содержащие процедуры и функции, которые используются только внутри модуля и не являются интерфейсными, именуются без дополнительного префикса.

# Правила работы с репозитарием.
## Структура репозитария.
Репозитарий имеет следующую структуру:

    Проект (тип документов)
      Группа модулей
        Модуль

В качестве типа документа используются: модели данных, описание архитектуры, код, unit-тесты. Внутри папок описывающих разные типы документов одинаковая структура. Каждому модулю соответствует своя папка в директории по каждому типу. Создавать новые папки в существующей структуре не рекомендуется.

## Правила именования файлов
Файл в репозитарии должен именоваться точно так же как называется объект БД, который в нем храниться. Кроме того к имени объекта через точку добавляется четырех символьный суффикс, описывающий тип объекта или тип части объекта. Далее через точку следует расширение файла «sql». Все файлы именуются в нижнем регистре.
Возможные варианты суффиксов:
<pre>
spec - содержит спецификацию пакета
body - содержит тело пакета
tabl - содержит структуру таблицы и комментарии к ней (и более ничего)
sqnc - содержит последовательность
indx - содержит индексы таблицы
cstr - содержит констрейнты на таблицу (первичный ключ, уникальный ключ)
trgr - содержит триггер на таблицу (файл именуется как таблица, а не как триггер)
type - содержит объектный тип
tpbd - содержит тело объектного типа
data - содержит данные для таблицы
view - содержит представление
mtvw - содержит материализованное представление
libr - подключаемая библиотека
</pre>

## Конфигурационные данные
Каждый модуль добавляет в общие справочники системы свои данные (словари, описания, настройки, события). Все подобные данные должны храниться в папке модуля, к которому эти данные относятся. В папке модуля создаются копии файлов с именем словарной таблицы и с данными относящимися только к этому модулю. Даже если словарная таблица относится к другому модулю.

## Создание конфигурации
1. Конфигурация создается либо с веб интерфейса, либо, при отсутствии форм, - с помощью UI-пакетов.
2. После создания конфигурацию нужно выгрузить с помощью пакета utl_data_pkg, например:

    SQL> exec utl_data_pkg.data_from_table('etalon', 'com_label', 'where id = 50000001');

3. Сохраните выгруженную конфигурацию в соответствующие файлы. Обратите внимание, что при выгрузке данных также подтягиваются мультиязычные описания - их надо сохранять в соответствующие языку раздельные файлы com_i18n.data.sql
4. В основной ветке используется только английский язык. Все локализованные данные хранятся в соответствующих языку каталогах папки ru.bpc.sv.custom/impl/db/lang

### Правила именования конфигурационных данных
Для того, чтобы конфигурация ядра не пересекалась с конфигурацией проектов, при создании объектов используйте префикс CST_, например, CST_CANNOT_SPEND_BONUS

### Сохранение больших текстовых данных (CLOB)
Для сохранения в репозитарий больших текстовых данных, например, шаблонов отчетов или сценариев банкоматов, необходимо использовать следующую технологию.
В скриптах данных для таблиц, имеющих поля с типом данных CLOB, данные для этих полей в самом скрипте не указываются. Текст, который необходимо сохранить в CLOB поле, сохраняется в отдельный файл. Имя файла формируется следующим образом: *[название_таблицы].[название_поля].[идентификатор_строки].[расширение_файла]*,
где расширением файла является настоящее расширение описывающее формат данных представленных в файле (XML, JRXML, TXT, HTML и т.п.), кроме формата SQL. Кодировка файлов с текстовыми данными - UTF-8 (UTF8 without BOM)
В той же папке, где находится скрипт на добавление записи в таблицу, создается подпапка "clob" (имя в нижнем регистре). В эту папку сохраняется файл, содержащий текстовые данные.

#### Очистка текста перед сохранением в базу
Тексты вставляются в базу построчно, поэтому перед сохранением удалите пустые строки, пробелы в конце, и знаки табуляции. Для очистки данных используйте редактор Notepad++, входящий в стандартный набор программ вашей рабочей машины: 

  Правка-Операции с Пробелами-Табуляцию в Пробел
  Правка-Операции с Пробелами-Убрать Замыкающие Пробелы
  
Текстовые файлы, содержащие данные с символами национальных алфавитов должны быть в кодировке UTF-8 (UTF-8 without BOM, ANSI as UTF-8).

### Правила сохранения данных

Одна строка в файле =  одна строка в таблице. Запрещены групповые операции над выгруженной конфигурацией. 
Изменение данных - только через конструкцию update

## Правила написания скриптов
Скрипты на создание изменение объектов пишутся инкрементально, то есть если необходимо добавить колонку в таблицу, то в скрипте на создание таблицы добавляется команда '''ALTER TABLE ADD COLUMN''', а не изменяется конструкция '''CREATE TABLE'''. Это связано с тем, что автоматический скрипт, применения изменений на эталонный инстанс, для скриптов на создание таблиц, индексов и прочего накатывает не весь скрипт, а только те строки, которые были добавлены с момента последней примененной ревизии. Исключение составляют такие объекты как представления, пакеты, триггеры, которые подменяют собой полностью старую версию объекта.
Если скрипт содержит несколько отдельных команд, то команды разделяются отдельной строкой с символом '/', а не ';'. Все пакеты и триггеры должны в конце так же содержать строку с символом '/'
* В конце каждого скрипта должна быть пустая строка


### Удаление объектов БД
Запрещено удалять файлы исходного кода.
Чтобы удалить объект, необходимо в конце исходного текста написать:
```sql
 drop object_type object_name
 /
 ```

Подробнее смотрите [Инкрементальные скрипты - правила написания кода](http://gitlab.bt.bpc.in/BackOffice/back/wikis/increment).

## Комментарии к изменениям
При сохранении изменений в репозитарий каждое изменение должно содержать развернутый комментарий на английском языке. Комментарий должен содержать информацию о сути сделанных изменений, описывать изменения в поведении системы в результате проведенных доработок. Также он обязательно должен содержать номер(а) задач инициировавших доработку.

## Партиционирование 
Партиционированию подлежат таблицы, в которых присутствует поле SPLIT_HASH. По этому полю создаются партиции с условием BY LIST. Количество партиций определяется параметром системы и едино для всех таблиц. Кроме того, если таблица является транзакционной она партиционируется по полю ID с условием BY RANGE. Обе разновидности партиционирования могут существовать по отдельности и совместно, в зависимости от конкретной ситуации. В случае двойного партиционирования по полю SPLIT_HASH создаются суб-партиции.
Для транзакционных таблиц вводится правило формирования идентификатора ID. Формат значения идентификатора - YYMMDDSSSSSSSSSS, где
-
YYMMDD - дата транзакции в определенном формате;
-
SSSSSSSSSS - зацикленная последовательность (sequence).
Таким образом, временные партиции нарезаются по дате т.к. она входит в состав идентификатора. Этот механизм позволяет создавать партиции заранее, не задевая при этом активную партицию. А также позволяет производить поиск данных по дате с подключением партиций.
В скрипты по созданию таблиц, которые, при наличии опции партиционирования, предполагается партиционировать, необходимо добавлять следующие конструкции:
С субпартициями

    /****************** partition start ********************
    partition by range (id)
    subpartition by list (split_hash)
    subpartition template
    (
    <subpartition_list>
    )
    (
    partition [table_name]_maxvalue values less than (maxvalue)
    )
    ******************** partition end ********************/

где [table_name] реальное имя таблицы
Без субпартиций

    /****************** partition start ********************
    
      partition by list (split_hash)

    (
    <partition_list>
    )
    ******************** partition end ********************/

### Партиционированные индексы
В глобальных индексах секции партиционирования описываются аналогично табличным, для локальных индексов нужно использовать вот такую конструкцию:
```sql
alter table opr_operation add (
    constraint opr_operation_pk primary key (id)
/****************** partition start ********************
    local
******************** partition end ********************/
)
/
```

# Ответственность уровней приложения при валидации данных
На каждый уровень приложения накладывается ответственность за валидацию данных. Все возможные проверки данных разделяются между уровнями приложений. Одни и те же проверки не должны проводиться несколько раз на разных уровнях. В приложении предполагается три уровня приложения: клиентский интерфейс, бизнес логика, база данных. Проверки делятся на три уровня следующим образом:

## Уровень Клиентского интерфейса
* Проверка соответствия значения типу данных
* Проверка корректности значения при существовании списка значений
* Проверка длины и размерности значения
* Проверка соответствия шаблону (регулярному выражению)
* Проверка обязательности значений


## Уровень Бизнес логики (PL/SQL)

* Подстановка значений по умолчанию
* Проверка ссылочной целостности, наличия введенных значений в БД
* Проверка сложных пересекающихся условий и взаимосвязей значений
* Проверка логической уникальности, не укладывающейся в возможности ключей


## Уровень Базы данных

* Проверка уникальности значений (в случае нарушения уникальности бизнес логика должна корректно обрабатывать исключение нарушения уникальности)


# Создание, регистрациия и выгрузка объектов базы данных
## Таблицы
Для таблицы создается:
* скрипт самой таблицы - modulecode_tablename.tabl.sql
* первичные и уникальные ключи - modulecode_tablename.cstr.sql
* индексы - modulecode_tablename.indx.sql
* сиквенс для первичного ключа по необходимости - modulecode_tablename_seq.sqnc.sql
* если для сущностей таблицы предусмотрен аудит:
** создается представление, содержащее все записи таблицы  - modulecode_tablename_vw.view.sql 
** код сущности регистрируются в com_dictionary  и вместе с именем таблицы регистрируются в adt_entity
* таблица и ее табличное пространство записываются в utl_table
* если таблица - справочник с доступом через ui:
** создается пакет modulecode_ui_tablename_pkg.spec.sql modulecode_ui_tablename_pkg.body.sql со стадартными методами add, modify и remove
** регистрируются привилегии на add, modify, remove и view

### Процессы
### Регистрация ошибок
### Регистрация параметров

### Быстрое пересоздание первичного ключа на таблице

Таких операций надо избегать - так как пересоздание первичного ключа на работающей базе может занимать много времени. Но бывают ситуации, когда это надо сделать. Первый пример - как делать не надо:
```sql
alter table acc_bunch drop primary key drop index
/
alter table acc_bunch add (
    constraint acc_bunch_pk primary key (id)
/****************** partition start ********************
    using index local
******************** partition end ********************/
)
/
```
1. Конструкция типа ``` alter table ... drop primary key drop index``` не является стандартной, правильно использовать вариант из документации Oracle:``` alter table acc_bunch drop constraint acc_bunch_pk```
2. Простое пересоздание индекса может занимать много времени, если данный скрипт будет выполняться в патче на *уже существующей системе*. Поэтому правильная последовательность команд выглядит вот так:

```sql

alter table acc_bunch drop constraint acc_bunch_pk cascade
/
alter table acc_bunch add constraint acc_bunch_pk primary key(id) disable
/
create unique index acc_bunch_pk on acc_bunch(id) 
/****************** partition start ********************
    using index local
******************** partition end ********************/
parallel 4 nologging
/
alter table acc_bunch enable primary key
/
alter index acc_bunch_pk noparallel
/
```
Пример кода в snippets: http://gitlab.bt.bpc.in/BackOffice/back/snippets/3
